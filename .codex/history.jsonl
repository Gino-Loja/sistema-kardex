{"session_id":"019b8c41-8cd7-7963-b0b3-ff52f2e4b366","ts":1767584730,"text":"c:\\Users\\ginol\\Desktop\\projects\\sistema-kardex\\.codex\\prompts\\speckit.implement.md\nimplementa de la T004 a T008 pero si ya esta hecho no."}
{"session_id":"019b8c41-8cd7-7963-b0b3-ff52f2e4b366","ts":1767585269,"text":"quiero que borres la carpeta db y solo se use drizzle"}
{"session_id":"019b8c41-8cd7-7963-b0b3-ff52f2e4b366","ts":1767585371,"text":"ademas quiero que los roles esten setados en en el plugin admin:\n# Admin\n\nAdmin plugin for Better Auth\n\n***\n\ntitle: Admin\ndescription: Admin plugin for Better Auth\n-----------------------------------------\n\nThe Admin plugin provides a set of administrative functions for user management in your application. It allows administrators to perform various operations such as creating users, managing user roles, banning/unbanning users, impersonating users, and more.\n\n## Installation\n\n<Steps>\n  <Step>\n    ### Add the plugin to your auth config\n\n    To use the Admin plugin, add it to your auth config.\n\n    ```ts title=\"auth.ts\"\n    import { betterAuth } from \"better-auth\"\n    import { admin } from \"better-auth/plugins\" // [!code highlight]\n\n    export const auth = betterAuth({\n        // ... other config options\n        plugins: [\n            admin() // [!code highlight]\n        ]\n    })\n    ```\n  </Step>\n\n  <Step>\n    ### Migrate the database\n\n    Run the migration or generate the schema to add the necessary fields and tables to the database.\n\n    <Tabs items={[\"migrate\", \"generate\"]}>\n      <Tab value=\"migrate\">\n        <CodeBlockTabs defaultValue=\"npm\">\n          <CodeBlockTabsList>\n            <CodeBlockTabsTrigger value=\"npm\">\n              npm\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"pnpm\">\n              pnpm\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"yarn\">\n              yarn\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"bun\">\n              bun\n            </CodeBlockTabsTrigger>\n          </CodeBlockTabsList>\n\n          <CodeBlockTab value=\"npm\">\n            ```bash\n            npx @better-auth/cli migrate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"pnpm\">\n            ```bash\n            pnpm dlx @better-auth/cli migrate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"yarn\">\n            ```bash\n            yarn dlx @better-auth/cli migrate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"bun\">\n            ```bash\n            bun x @better-auth/cli migrate\n            ```\n          </CodeBlockTab>\n        </CodeBlockTabs>\n      </Tab>\n\n      <Tab value=\"generate\">\n        <CodeBlockTabs defaultValue=\"npm\">\n          <CodeBlockTabsList>\n            <CodeBlockTabsTrigger value=\"npm\">\n              npm\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"pnpm\">\n              pnpm\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"yarn\">\n              yarn\n            </CodeBlockTabsTrigger>\n\n            <CodeBlockTabsTrigger value=\"bun\">\n              bun\n            </CodeBlockTabsTrigger>\n          </CodeBlockTabsList>\n\n          <CodeBlockTab value=\"npm\">\n            ```bash\n            npx @better-auth/cli generate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"pnpm\">\n            ```bash\n            pnpm dlx @better-auth/cli generate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"yarn\">\n            ```bash\n            yarn dlx @better-auth/cli generate\n            ```\n          </CodeBlockTab>\n\n          <CodeBlockTab value=\"bun\">\n            ```bash\n            bun x @better-auth/cli generate\n            ```\n          </CodeBlockTab>\n        </CodeBlockTabs>\n      </Tab>\n    </Tabs>\n\n    See the [Schema](#schema) section to add the fields manually.\n  </Step>\n\n  <Step>\n    ### Add the client plugin\n\n    Next, include the admin client plugin in your authentication client instance.\n\n    ```ts title=\"auth-client.ts\"\n    import { createAuthClient } from \"better-auth/client\"\n    import { adminClient } from \"better-auth/client/plugins\"\n\n    export const authClient = createAuthClient({\n        plugins: [\n            adminClient()\n        ]\n    })\n    ```\n  </Step>\n</Steps>\n\n## Usage\n\nBefore performing any admin operations, the user must be authenticated with an admin account. An admin is any user assigned the `admin` role or any user whose ID is included in the `adminUserIds` option.\n\n### Create User\n\nAllows an admin to create a new user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.createUser({\n    email: user@example.com,\n    password: some-secure-password,\n    name: James Smith,\n    role: user, // optional\n    data, // optional\n});\n```\n\n### Server Side\n\n```ts\nconst newUser = await auth.api.createUser({\n    body: {\n        email: user@example.com,\n        password: some-secure-password,\n        name: James Smith,\n        role: user, // optional\n        data, // optional\n    }\n});\n```\n\n### Type Definition\n\n```ts\ntype createUser = {\n    /**\n     * The email of the user. \n     */\n    email: string = \"user@example.com\"\n    /**\n     * The password of the user. \n     */\n    password: string = \"some-secure-password\"\n    /**\n     * The name of the user. \n     */\n    name: string = \"James Smith\"\n    /**\n     * A string or array of strings representing the roles to apply to the new user. \n     */\n    role?: string | string[] = \"user\"\n    /**\n     * Extra fields for the user. Including custom additional fields. \n     */\n    data?: Record<string, any> = { customField: \"customValue\" \n}\n```\n\n### List Users\n\nAllows an admin to list all users in the database.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.listUsers({\n    searchValue: some name, // optional\n    searchField: name, // optional\n    searchOperator: contains, // optional\n    limit, // optional\n    offset, // optional\n    sortBy: name, // optional\n    sortDirection: desc, // optional\n    filterField: email, // optional\n    filterValue: hello@example.com, // optional\n    filterOperator: eq, // optional\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.listUsers({\n    query: {\n        searchValue: some name, // optional\n        searchField: name, // optional\n        searchOperator: contains, // optional\n        limit, // optional\n        offset, // optional\n        sortBy: name, // optional\n        sortDirection: desc, // optional\n        filterField: email, // optional\n        filterValue: hello@example.com, // optional\n        filterOperator: eq, // optional\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype listUsers = {\n  /**\n   * The value to search for. \n   */\n  searchValue?: string = \"some name\"\n  /**\n   * The field to search in, defaults to email. Can be `email` or `name`. \n   */\n  searchField?: \"email\" | \"name\" = \"name\"\n  /**\n   * The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. \n   */\n  searchOperator?: \"contains\" | \"starts_with\" | \"ends_with\" = \"contains\"\n  /**\n   * The number of users to return. Defaults to 100.\n   */\n  limit?: string | number = 100\n  /**\n   * The offset to start from. \n   */\n  offset?: string | number = 100\n  /**\n   * The field to sort by. \n   */\n  sortBy?: string = \"name\"\n  /**\n   * The direction to sort by. \n   */\n  sortDirection?: \"asc\" | \"desc\" = \"desc\"\n  /**\n   * The field to filter by. \n   */\n  filterField?: string = \"email\"\n  /**\n   * The value to filter by. \n   */\n  filterValue?: string | number | boolean = \"hello@example.com\"\n  /**\n   * The operator to use for the filter. \n   */\n  filterOperator?: \"eq\" | \"ne\" | \"lt\" | \"lte\" | \"gt\" | \"gte\" = \"eq\"\n\n}\n```\n\n#### Query Filtering\n\nThe `listUsers` function supports various filter operators including `eq`, `contains`, `starts_with`, and `ends_with`.\n\n#### Pagination\n\nThe `listUsers` function supports pagination by returning metadata alongside the user list. The response includes the following fields:\n\n```ts\n{\n  users: User[],   // Array of returned users\n  total: number,   // Total number of users after filters and search queries\n  limit: number | undefined,   // The limit provided in the query\n  offset: number | undefined   // The offset provided in the query\n}\n```\n\n##### How to Implement Pagination\n\nTo paginate results, use the `total`, `limit`, and `offset` values to calculate:\n\n* **Total pages:** `Math.ceil(total / limit)`\n* **Current page:** `(offset / limit) + 1`\n* **Next page offset:** `Math.min(offset + limit, (total - 1))`  The value to use as `offset` for the next page, ensuring it does not exceed the total number of pages.\n* **Previous page offset:** `Math.max(0, offset - limit)`  The value to use as `offset` for the previous page (ensuring it doesnt go below zero).\n\n##### Example Usage\n\nFetching the second page with 10 users per page:\n\n```ts title=\"admin.ts\"\nconst pageSize = 10;\nconst currentPage = 2;\n\nconst users = await authClient.admin.listUsers({\n    query: {\n        limit: pageSize,\n        offset: (currentPage - 1) * pageSize\n    }\n});\n\nconst totalUsers = users.total;\nconst totalPages = Math.ceil(totalUsers / pageSize)\n```\n\n### Set User Role\n\nChanges the role of a user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.setRole({\n    userId: user-id, // optional\n    role: admin,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.setRole({\n    body: {\n        userId: user-id, // optional\n        role: admin,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype setRole = {\n    /**\n     * The user id which you want to set the role for.\n     */\n    userId?: string = \"user-id\"\n    /**\n     * The role to set, this can be a string or an array of strings. \n     */\n    role: string | string[] = \"admin\"\n\n}\n```\n\n### Set User Password\n\nChanges the password of a user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.setUserPassword({\n    newPassword: new-password,\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.setUserPassword({\n    body: {\n        newPassword: new-password,\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype setUserPassword = {\n    /**\n     * The new password. \n     */\n    newPassword: string = 'new-password'\n    /**\n     * The user id which you want to set the password for.\n     */\n    userId: string = 'user-id'\n\n}\n```\n\n### Update user\n\nUpdate a user's details.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.updateUser({\n    userId: user-id,\n    data,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.adminUpdateUser({\n    body: {\n        userId: user-id,\n        data,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype adminUpdateUser = {\n    /**\n     * The user id which you want to update.\n     */\n    userId: string = \"user-id\"\n    /**\n     * The data to update.\n     */\n    data: Record<string, any> = { name: \"John Doe\" \n}\n```\n\n### Ban User\n\nBans a user, preventing them from signing in and revokes all of their existing sessions.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.banUser({\n    userId: user-id,\n    banReason: Spamming, // optional\n    banExpiresIn, // optional\n});\n```\n\n### Server Side\n\n```ts\nawait auth.api.banUser({\n    body: {\n        userId: user-id,\n        banReason: Spamming, // optional\n        banExpiresIn, // optional\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype banUser = {\n    /**\n     * The user id which you want to ban.\n     */\n    userId: string = \"user-id\"\n    /**\n     * The reason for the ban. \n     */\n    banReason?: string = \"Spamming\"\n    /**\n     * The number of seconds until the ban expires. If not provided, the ban will never expire. \n     */\n    banExpiresIn?: number = 60 * 60 * 24 * 7\n\n}\n```\n\n### Unban User\n\nRemoves the ban from a user, allowing them to sign in again.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.unbanUser({\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nawait auth.api.unbanUser({\n    body: {\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype unbanUser = {\n    /**\n     * The user id which you want to unban.\n     */\n    userId: string = \"user-id\"\n\n}\n```\n\n### List User Sessions\n\nLists all sessions for a user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.listUserSessions({\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.listUserSessions({\n    body: {\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype listUserSessions = {\n    /**\n     * The user id. \n     */\n    userId: string = \"user-id\"\n\n}\n```\n\n### Revoke User Session\n\nRevokes a specific session for a user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.revokeUserSession({\n    sessionToken: session_token_here,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.revokeUserSession({\n    body: {\n        sessionToken: session_token_here,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype revokeUserSession = {\n    /**\n     * The session token which you want to revoke. \n     */\n    sessionToken: string = \"session_token_here\"\n\n}\n```\n\n### Revoke All Sessions for a User\n\nRevokes all sessions for a user.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.revokeUserSessions({\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.revokeUserSessions({\n    body: {\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype revokeUserSessions = {\n    /**\n     * The user id which you want to revoke all sessions for. \n     */\n    userId: string = \"user-id\"\n\n}\n```\n\n### Impersonate User\n\nThis feature allows an admin to create a session that mimics the specified user. The session will remain active until either the browser session ends or it reaches 1 hour. You can change this duration by setting the `impersonationSessionDuration` option.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.impersonateUser({\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.impersonateUser({\n    body: {\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype impersonateUser = {\n    /**\n     * The user id which you want to impersonate. \n     */\n    userId: string = \"user-id\"\n\n}\n```\n\n### Stop Impersonating User\n\nTo stop impersonating a user and continue with the admin account, you can use `stopImpersonating`\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.stopImpersonating({});\n```\n\n### Server Side\n\n```ts\nawait auth.api.stopImpersonating({\n\n    // This endpoint requires session cookies\n.    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype stopImpersonating = {\n\n}\n```\n\n### Remove User\n\nHard deletes a user from the database.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.removeUser({\n    userId: user-id,\n});\n```\n\n### Server Side\n\n```ts\nconst deletedUser = await auth.api.removeUser({\n    body: {\n        userId: user-id,\n    },\n    // This endpoint requires session cookies.\n    headers: await headers()\n});\n```\n\n### Type Definition\n\n```ts\ntype removeUser = {\n    /**\n     * The user id which you want to remove. \n     */\n    userId: string = \"user-id\"\n\n}\n```\n\n## Access Control\n\nThe admin plugin offers a highly flexible access control system, allowing you to manage user permissions based on their role. You can define custom permission sets to fit your needs.\n\n### Roles\n\nBy default, there are two roles:\n\n`admin`: Users with the admin role have full control over other users.\n\n`user`: Users with the user role have no control over other users.\n\n<Callout>\n  A user can have multiple roles. Multiple roles are stored as string separated by comma (\",\").\n</Callout>\n\n### Permissions\n\nBy default, there are two resources with up to six permissions.\n\n**user**:\n`create` `list` `set-role` `ban` `impersonate` `delete` `set-password`\n\n**session**:\n`list` `revoke` `delete`\n\nUsers with the admin role have full control over all the resources and actions. Users with the user role have no control over any of those actions.\n\n### Custom Permissions\n\nThe plugin provides an easy way to define your own set of permissions for each role.\n\n<Steps>\n  <Step>\n    #### Create Access Control\n\n    You first need to create an access controller by calling the `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value.\n\n    ```ts title=\"permissions.ts\"\n    import { createAccessControl } from \"better-auth/plugins/access\";\n\n    /**\n     * make sure to use `as const` so typescript can infer the type correctly\n     */\n    const statement = { // [!code highlight]\n        project: [\"create\", \"share\", \"update\", \"delete\"], // [!code highlight]\n    } as const; // [!code highlight]\n\n    const ac = createAccessControl(statement); // [!code highlight]\n    ```\n  </Step>\n\n  <Step>\n    #### Create Roles\n\n    Once you have created the access controller you can create roles with the permissions you have defined.\n\n    ```ts title=\"permissions.ts\"\n    import { createAccessControl } from \"better-auth/plugins/access\";\n\n    export const statement = {\n        project: [\"create\", \"share\", \"update\", \"delete\"], // <-- Permissions available for created roles\n    } as const;\n\n    const ac = createAccessControl(statement);\n\n    export const user = ac.newRole({ // [!code highlight]\n        project: [\"create\"], // [!code highlight]\n    }); // [!code highlight]\n\n    export const admin = ac.newRole({ // [!code highlight]\n        project: [\"create\", \"update\"], // [!code highlight]\n    }); // [!code highlight]\n\n    export const myCustomRole = ac.newRole({ // [!code highlight]\n        project: [\"create\", \"update\", \"delete\"], // [!code highlight]\n        user: [\"ban\"], // [!code highlight]\n    }); // [!code highlight]\n    ```\n\n    When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles.\n\n    ```ts title=\"permissions.ts\"\n    import { createAccessControl } from \"better-auth/plugins/access\";\n    import { defaultStatements, adminAc } from \"better-auth/plugins/admin/access\";\n\n    const statement = {\n        ...defaultStatements, // [!code highlight]\n        project: [\"create\", \"share\", \"update\", \"delete\"],\n    } as const;\n\n    const ac = createAccessControl(statement);\n\n    const admin = ac.newRole({\n        project: [\"create\", \"update\"],\n        ...adminAc.statements, // [!code highlight]\n    });\n    ```\n  </Step>\n\n  <Step>\n    #### Pass Roles to the Plugin\n\n    Once you have created the roles you can pass them to the admin plugin both on the client and the server.\n\n    ```ts title=\"auth.ts\"\n    import { betterAuth } from \"better-auth\"\n    import { admin as adminPlugin } from \"better-auth/plugins\"\n    import { ac, admin, user } from \"@/auth/permissions\"\n\n    export const auth = betterAuth({\n        plugins: [\n            adminPlugin({\n                ac,\n                roles: {\n                    admin,\n                    user,\n                    myCustomRole\n                }\n            }),\n        ],\n    });\n    ```\n\n    You also need to pass the access controller and the roles to the client plugin.\n\n    ```ts title=\"auth-client.ts\"\n    import { createAuthClient } from \"better-auth/client\"\n    import { adminClient } from \"better-auth/client/plugins\"\n    import { ac, admin, user, myCustomRole } from \"@/auth/permissions\"\n\n    export const client = createAuthClient({\n        plugins: [\n            adminClient({\n                ac,\n                roles: {\n                    admin,\n                    user,\n                    myCustomRole\n                }\n            })\n        ]\n    })\n    ```\n  </Step>\n</Steps>\n\n### Access Control Usage\n\n**Has Permission**:\n\nTo check a user's permissions, you can use the `hasPermission` function provided by the client.\n\n### Client Side\n\n```ts\nconst { data, error } = await authClient.admin.hasPermission({\n    userId: user-id, // optional\n    role: admin, // optional\n    permission, // optional\n});\n```\n\n### Server Side\n\n```ts\nconst data = await auth.api.userHasPermission({\n    body: {\n        userId: user-id, // optional\n        role: admin, // optional\n        permission, // optional\n    }\n});\n```\n\n### Type Definition\n\n```ts\ntype userHasPermission = {\n    /**\n     * The user id which you want to check the permissions for. \n     */\n    userId?: string = \"user-id\"\n    /**\n     * Check role permissions.\n     * @serverOnly\n     */\n    role?: string = \"admin\"\n    /**\n     * Optionally check if a single permission is granted. Must use this, or permissions. \n     */\n    permission?: Record<string, string[]> = { \"project\": [\"create\", \"update\"] \n}\n```\n\nExample usage:\n\n```ts title=\"auth-client.ts\"\nconst canCreateProject = await authClient.admin.hasPermission({\n  permissions: {\n    project: [\"create\"],\n  },\n});\n\n// You can also check multiple resource permissions at the same time\nconst canCreateProjectAndCreateSale = await authClient.admin.hasPermission({\n  permissions: {\n    project: [\"create\"],\n    sale: [\"create\"]\n  },\n});\n```\n\nIf you want to check a user's permissions server-side, you can use the `userHasPermission` action provided by the `api` to check the user's permissions.\n\n```ts title=\"api.ts\"\nimport { auth } from \"@/auth\";\n\nawait auth.api.userHasPermission({\n  body: {\n    userId: 'id', //the user id\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n    },\n  },\n});\n\n// You can also just pass the role directly\nawait auth.api.userHasPermission({\n  body: {\n   role: \"admin\",\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n    },\n  },\n});\n\n// You can also check multiple resource permissions at the same time\nawait auth.api.userHasPermission({\n  body: {\n   role: \"admin\",\n    permissions: {\n      project: [\"create\"], // This must match the structure in your access control\n      sale: [\"create\"]\n    },\n  },\n});\n```\n\n**Check Role Permission**:\n\nUse the `checkRolePermission` function on the client side to verify whether a given **role** has a specific **permission**. This is helpful after defining roles and their permissions, as it allows you to perform permission checks without needing to contact the server.\n\nNote that this function does **not** check the permissions of the currently logged-in user directly. Instead, it checks what permissions are assigned to a specified role. The function is synchronous, so you don't need to use `await` when calling it.\n\n```ts title=\"auth-client.ts\"\nconst canCreateProject = authClient.admin.checkRolePermission({\n  permissions: {\n    user: [\"delete\"],\n  },\n  role: \"admin\",\n});\n\n// You can also check multiple resource permissions at the same time\nconst canDeleteUserAndRevokeSession = authClient.admin.checkRolePermission({\n  permissions: {\n    user: [\"delete\"],\n    session: [\"revoke\"]\n  },\n  role: \"admin\",\n});\n```\n\n## Schema\n\nThis plugin adds the following fields to the `user` table:\n\n<DatabaseTable\n  fields={[\n  {\n    name: \"role\",\n    type: \"string\",\n    description:\n      \"The user's role. Defaults to `user`. Admins will have the `admin` role.\",\n    isOptional: true,\n  },\n  {\n    name: \"banned\",\n    type: \"boolean\",\n    description: \"Indicates whether the user is banned.\",\n    isOptional: true,\n  },\n  {\n    name: \"banReason\",\n    type: \"string\",\n    description: \"The reason for the user's ban.\",\n    isOptional: true,\n  },\n  {\n    name: \"banExpires\",\n    type: \"date\",\n    description: \"The date when the user's ban will expire.\",\n    isOptional: true,\n  },\n]}\n/>\n\nAnd adds one field in the `session` table:\n\n<DatabaseTable\n  fields={[\n  {\n    name: \"impersonatedBy\",\n    type: \"string\",\n    description: \"The ID of the admin that is impersonating this session.\",\n    isOptional: true,\n  },\n]}\n/>\n\n## Options\n\n### Default Role\n\nThe default role for a user. Defaults to `user`.\n\n```ts title=\"auth.ts\"\nadmin({\n  defaultRole: \"regular\",\n});\n```\n\n### Admin Roles\n\nThe roles that are considered admin roles when **not** using custom access control. Defaults to `[\"admin\"]`.\n\n```ts title=\"auth.ts\"\nadmin({\n  adminRoles: [\"admin\", \"superadmin\"],\n});\n```\n\n<Callout type=\"warning\">\n  **Note:** The `adminRoles` option is **not required** when using custom access control (via `ac` and `roles`). When you define custom roles with specific permissions, those roles will have exactly the permissions you grant them through the access control system.\n\n  **Warning:** When **not** using custom access control, any role that isn't in the `adminRoles` list will **not** be able to perform admin operations.\n</Callout>\n\n### Admin userIds\n\nYou can pass an array of userIds that should be considered as admin. Default to `[]`\n\n```ts title=\"auth.ts\"\nadmin({\n    adminUserIds: [\"user_id_1\", \"user_id_2\"]\n})\n```\n\nIf a user is in the `adminUserIds` list, they will be able to perform any admin operation.\n\n### impersonationSessionDuration\n\nThe duration of the impersonation session in seconds. Defaults to 1 hour.\n\n```ts title=\"auth.ts\"\nadmin({\n  impersonationSessionDuration: 60 * 60 * 24, // 1 day\n});\n```\n\n### Default Ban Reason\n\nThe default ban reason for a user created by the admin. Defaults to `No reason`.\n\n```ts title=\"auth.ts\"\nadmin({\n  defaultBanReason: \"Spamming\",\n});\n```\n\n### Default Ban Expires In\n\nThe default ban expires in for a user created by the admin in seconds. Defaults to `undefined` (meaning the ban never expires).\n\n```ts title=\"auth.ts\"\nadmin({\n  defaultBanExpiresIn: 60 * 60 * 24, // 1 day\n});\n```\n\n### bannedUserMessage\n\nThe message to show when a banned user tries to sign in. Defaults to \"You have been banned from this application. Please contact support if you believe this is an error.\"\n\n```ts title=\"auth.ts\"\nadmin({\n  bannedUserMessage: \"Custom banned user message\",\n});\n```\n\n### allowImpersonatingAdmins\n\nWhether to allow impersonating other admin users. Defaults to `false`.\n\n```ts title=\"auth.ts\"\nadmin({\n  allowImpersonatingAdmins: true,\n});\n```"}
{"session_id":"019b8c41-8cd7-7963-b0b3-ff52f2e4b366","ts":1767585455,"text":"Si quieres, también puedo alinear esto con tus roles internos (src/lib/auth/roles.ts) o agregar access control personalizado. si por favor"}
{"session_id":"019b99eb-0a2a-75c1-bb8b-9d8c4db840a3","ts":1767813887,"text":"C:\\Users\\ginol\\Desktop\\projects\\sistema-kardex.codex\\prompts\\speckit.implement.md\nimplementa de la T030 hasta T041"}
{"session_id":"019b9a32-d31b-7ab0-b935-2c208696a8f9","ts":1767818600,"text":"\n## User Input\n\n```text\n\n```\n\nYou **MUST** consider the user input before proceeding (if not empty).\n\n## Outline\n\nThe text the user typed after `/speckit.specify` in the triggering message **is** the feature description. Assume you always have it available in this conversation even if `` appears literally below. Do not ask the user to repeat it unless they provided an empty command.\n\nGiven that feature description, do this:\n\n1. **Generate a concise short name** (2-4 words) for the branch:\n   - Analyze the feature description and extract the most meaningful keywords\n   - Create a 2-4 word short name that captures the essence of the feature\n   - Use action-noun format when possible (e.g., \"add-user-auth\", \"fix-payment-bug\")\n   - Preserve technical terms and acronyms (OAuth2, API, JWT, etc.)\n   - Keep it concise but descriptive enough to understand the feature at a glance\n   - Examples:\n     - \"I want to add user authentication\" → \"user-auth\"\n     - \"Implement OAuth2 integration for the API\" → \"oauth2-api-integration\"\n     - \"Create a dashboard for analytics\" → \"analytics-dashboard\"\n     - \"Fix payment processing timeout bug\" → \"fix-payment-timeout\"\n\n2. **Check for existing branches before creating new one**:\n\n   a. First, fetch all remote branches to ensure we have the latest information:\n\n      ```bash\n      git fetch --all --prune\n      ```\n\n   b. Find the highest feature number across all sources for the short-name:\n      - Remote branches: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - Local branches: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - Specs directories: Check for directories matching `specs/[0-9]+-<short-name>`\n\n   c. Determine the next available number:\n      - Extract all numbers from all three sources\n      - Find the highest number N\n      - Use N+1 for the new branch number\n\n   d. Run the script `.specify/scripts/powershell/create-new-feature.ps1 -Json \"\"` with the calculated number and short-name:\n      - Pass `--number N+1` and `--short-name \"your-short-name\"` along with the feature description\n      - Bash example: `.specify/scripts/powershell/create-new-feature.ps1 -Json \"\" --json --number 5 --short-name \"user-auth\" \"Add user authentication\"`\n      - PowerShell example: `.specify/scripts/powershell/create-new-feature.ps1 -Json \"\" -Json -Number 5 -ShortName \"user-auth\" \"Add user authentication\"`\n\n   **IMPORTANT**:\n   - Check all three sources (remote branches, local branches, specs directories) to find the highest number\n   - Only match branches/directories with the exact short-name pattern\n   - If no existing branches/directories found with this short-name, start with number 1\n   - You must only ever run this script once per feature\n   - The JSON is provided in the terminal as output - always refer to it to get the actual content you're looking for\n   - The JSON output will contain BRANCH_NAME and SPEC_FILE paths\n   - For single quotes in args like \"I'm Groot\", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: \"I'm Groot\")\n\n3. Load `.specify/templates/spec-template.md` to understand required sections.\n\n4. Follow this execution flow:\n\n    1. Parse user description from Input\n       If empty: ERROR \"No feature description provided\"\n    2. Extract key concepts from description\n       Identify: actors, actions, data, constraints\n    3. For unclear aspects:\n       - Make informed guesses based on context and industry standards\n       - Only mark with [NEEDS CLARIFICATION: specific question] if:\n         - The choice significantly impacts feature scope or user experience\n         - Multiple reasonable interpretations exist with different implications\n         - No reasonable default exists\n       - **LIMIT: Maximum 3 [NEEDS CLARIFICATION] markers total**\n       - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details\n    4. Fill User Scenarios & Testing section\n       If no clear user flow: ERROR \"Cannot determine user scenarios\"\n    5. Generate Functional Requirements\n       Each requirement must be testable\n       Use reasonable defaults for unspecified details (document assumptions in Assumptions section)\n    6. Define Success Criteria\n       Create measurable, technology-agnostic outcomes\n       Include both quantitative metrics (time, performance, volume) and qualitative measures (user satisfaction, task completion)\n       Each criterion must be verifiable without implementation details\n    7. Identify Key Entities (if data involved)\n    8. Return: SUCCESS (spec ready for planning)\n\n5. Write the specification to SPEC_FILE using the template structure, replacing placeholders with concrete details derived from the feature description (arguments) while preserving section order and headings.\n\n6. **Specification Quality Validation**: After writing the initial spec, validate it against quality criteria:\n\n   a. **Create Spec Quality Checklist**: Generate a checklist file at `FEATURE_DIR/checklists/requirements.md` using the checklist template structure with these validation items:\n\n      ```markdown\n      # Specification Quality Checklist: [FEATURE NAME]\n      \n      **Purpose**: Validate specification completeness and quality before proceeding to planning\n      **Created**: [DATE]\n      **Feature**: [Link to spec.md]\n      \n      ## Content Quality\n      \n      - [ ] No implementation details (languages, frameworks, APIs)\n      - [ ] Focused on user value and business needs\n      - [ ] Written for non-technical stakeholders\n      - [ ] All mandatory sections completed\n      \n      ## Requirement Completeness\n      \n      - [ ] No [NEEDS CLARIFICATION] markers remain\n      - [ ] Requirements are testable and unambiguous\n      - [ ] Success criteria are measurable\n      - [ ] Success criteria are technology-agnostic (no implementation details)\n      - [ ] All acceptance scenarios are defined\n      - [ ] Edge cases are identified\n      - [ ] Scope is clearly bounded\n      - [ ] Dependencies and assumptions identified\n      \n      ## Feature Readiness\n      \n      - [ ] All functional requirements have clear acceptance criteria\n      - [ ] User scenarios cover primary flows\n      - [ ] Feature meets measurable outcomes defined in Success Criteria\n      - [ ] No implementation details leak into specification\n      \n      ## Notes\n      \n      - Items marked incomplete require spec updates before `/speckit.clarify` or `/speckit.plan`\n      ```\n\n   b. **Run Validation Check**: Review the spec against each checklist item:\n      - For each item, determine if it passes or fails\n      - Document specific issues found (quote relevant spec sections)\n\n   c. **Handle Validation Results**:\n\n      - **If all items pass**: Mark checklist complete and proceed to step 6\n\n      - **If items fail (excluding [NEEDS CLARIFICATION])**:\n        1. List the failing items and specific issues\n        2. Update the spec to address each issue\n        3. Re-run validation until all items pass (max 3 iterations)\n        4. If still failing after 3 iterations, document remaining issues in checklist notes and warn user\n\n      - **If [NEEDS CLARIFICATION] markers remain**:\n        1. Extract all [NEEDS CLARIFICATION: ...] markers from the spec\n        2. **LIMIT CHECK**: If more than 3 markers exist, keep only the 3 most critical (by scope/security/UX impact) and make informed guesses for the rest\n        3. For each clarification needed (max 3), present options to user in this format:\n\n           ```markdown\n           ## Question [N]: [Topic]\n           \n           **Context**: [Quote relevant spec section]\n           \n           **What we need to know**: [Specific question from NEEDS CLARIFICATION marker]\n           \n           **Suggested Answers**:\n           \n           | Option | Answer | Implications |\n           |--------|--------|--------------|\n           | A      | [First suggested answer] | [What this means for the feature] |\n           | B      | [Second suggested answer] | [What this means for the feature] |\n           | C      | [Third suggested answer] | [What this means for the feature] |\n           | Custom | Provide your own answer | [Explain how to provide custom input] |\n           \n           **Your choice**: _[Wait for user response]_\n           ```\n\n        4. **CRITICAL - Table Formatting**: Ensure markdown tables are properly formatted:\n           - Use consistent spacing with pipes aligned\n           - Each cell should have spaces around content: `| Content |` not `|Content|`\n           - Header separator must have at least 3 dashes: `|--------|`\n           - Test that the table renders correctly in markdown preview\n        5. Number questions sequentially (Q1, Q2, Q3 - max 3 total)\n        6. Present all questions together before waiting for responses\n        7. Wait for user to respond with their choices for all questions (e.g., \"Q1: A, Q2: Custom - [details], Q3: B\")\n        8. Update the spec by replacing each [NEEDS CLARIFICATION] marker with the user's selected or provided answer\n        9. Re-run validation after all clarifications are resolved\n\n   d. **Update Checklist**: After each validation iteration, update the checklist file with current pass/fail status\n\n7. Report completion with branch name, spec file path, checklist results, and readiness for the next phase (`/speckit.clarify` or `/speckit.plan`).\n\n**NOTE:** The script creates and checks out the new branch and initializes the spec file before writing.\n\n## General Guidelines\n\n## Quick Guidelines\n\n- Focus on **WHAT** users need and **WHY**.\n- Avoid HOW to implement (no tech stack, APIs, code structure).\n- Written for business stakeholders, not developers.\n- DO NOT create any checklists that are embedded in the spec. That will be a separate command.\n\n### Section Requirements\n\n- **Mandatory sections**: Must be completed for every feature\n- **Optional sections**: Include only when relevant to the feature\n- When a section doesn't apply, remove it entirely (don't leave as \"N/A\")\n\n### For AI Generation\n\nWhen creating this spec from a user prompt:\n\n1. **Make informed guesses**: Use context, industry standards, and common patterns to fill gaps\n2. **Document assumptions**: Record reasonable defaults in the Assumptions section\n3. **Limit clarifications**: Maximum 3 [NEEDS CLARIFICATION] markers - use only for critical decisions that:\n   - Significantly impact feature scope or user experience\n   - Have multiple reasonable interpretations with different implications\n   - Lack any reasonable default\n4. **Prioritize clarifications**: scope > security/privacy > user experience > technical details\n5. **Think like a tester**: Every vague requirement should fail the \"testable and unambiguous\" checklist item\n6. **Common areas needing clarification** (only if no reasonable default exists):\n   - Feature scope and boundaries (include/exclude specific use cases)\n   - User types and permissions (if multiple conflicting interpretations possible)\n   - Security/compliance requirements (when legally/financially significant)\n\n**Examples of reasonable defaults** (don't ask about these):\n\n- Data retention: Industry-standard practices for the domain\n- Performance targets: Standard web/mobile app expectations unless specified\n- Error handling: User-friendly messages with appropriate fallbacks\n- Authentication method: Standard session-based or OAuth2 for web apps\n- Integration patterns: RESTful APIs unless specified otherwise\n\n### Success Criteria Guidelines\n\nSuccess criteria must be:\n\n1. **Measurable**: Include specific metrics (time, percentage, count, rate)\n2. **Technology-agnostic**: No mention of frameworks, languages, databases, or tools\n3. **User-focused**: Describe outcomes from user/business perspective, not system internals\n4. **Verifiable**: Can be tested/validated without knowing implementation details\n\n**Good examples**:\n\n- \"Users can complete checkout in under 3 minutes\"\n- \"System supports 10,000 concurrent users\"\n- \"95% of searches return results in under 1 second\"\n- \"Task completion rate improves by 40%\"\n\n**Bad examples** (implementation-focused):\n\n- \"API response time is under 200ms\" (too technical, use \"Users see results instantly\")\n- \"Database can handle 1000 TPS\" (implementation detail, use user-facing metric)\n- \"React components render efficiently\" (framework-specific)\n- \"Redis cache hit rate above 80%\" (technology-specific)\n"}
{"session_id":"019b9a32-d31b-7ab0-b935-2c208696a8f9","ts":1767818631,"text":"\"Actúa como un experto en Next.js y shadcn/ui. Crea un componente de Sidebar y un Navbar para una aplicación profesional utilizando el preset 'Nova' con tema 'Yellow'.\nEspecificaciones Técnicas:\n\nStack: Next.js (App Router), Tailwind CSS, TypeScript.\n\nIconos: Usa exclusivamente la librería @tabler/icons-react.\n\nSidebar: > - Debe ser colapsable y utilizar el componente oficial Sidebar de shadcn.\n\nEstructura: Header con logo, buscador (SidebarInput), sección de navegación (Dashboard, Proyectos, Reportes) y Footer con perfil de usuario.\n\nEstado Activo: Usa usePathname para detectar la ruta actual. El item activo debe tener un fondo amarillo (bg-primary) y texto que contraste (text-primary-foreground), siguiendo el esquema del tema 'yellow'.\n\nNavbar: > - Debe ser fijo en la parte superior.\n\nIncluye el SidebarTrigger a la izquierda.\n\nAñade un sistema de 'Breadcrumbs' dinámico y un menú de notificaciones o perfil a la derecha.\n\nDiseño: Fondo con desenfoque (backdrop-blur) y borde inferior sutil.\n\nResponsividad: El sidebar debe ocultarse en móviles y abrirse mediante el gatillo (trigger) del Navbar como un panel lateral.\n\nEstilo Nova: Asegúrate de que los bordes sean pequeños (radius: small) y el espaciado sea limpio, acorde al estilo Nova de shadcn."}
